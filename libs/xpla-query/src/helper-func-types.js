"use strict";
/**
* This file and any referenced files were automatically generated by @cosmology/telescope@1.10.11
* DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
* and run the transpile command or npm scripts command that is used to regenerate this bundle.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildQuery = buildQuery;
exports.isISigningClient = isISigningClient;
exports.buildTx = buildTx;
const extern_1 = require("./extern");
const helpers_1 = require("./helpers");
function buildQuery(opts) {
    return async (request) => {
        let rpc;
        if ((0, helpers_1.isRpc)(opts.clientResolver)) {
            rpc = opts.clientResolver;
        }
        else {
            rpc = opts.clientResolver ? await (0, extern_1.getRpcClient)(opts.clientResolver) : undefined;
        }
        if (!rpc)
            throw new Error("Query Rpc is not initialized");
        const data = opts.encode(request).finish();
        const response = await rpc.request(opts.service, opts.method, data);
        return opts.decode(response);
    };
}
function isISigningClient(client) {
    return client !== null && client !== undefined
        && typeof client.signAndBroadcast === 'function'
        && typeof client.addConverters === 'function'
        && typeof client.addEncoders === 'function';
}
function buildTx(opts) {
    return async (signerAddress, message, fee, memo) => {
        let client;
        // if opts.getSigningClient is a function, call it to get the SigningClient instance
        if (isISigningClient(opts.clientResolver)) {
            client = opts.clientResolver;
        }
        if (!client)
            throw new Error("SigningClient is not initialized");
        //register all related encoders and converters
        client.addEncoders(opts.encoders ?? []);
        client.addConverters(opts.converters ?? []);
        const data = [
            {
                typeUrl: opts.typeUrl,
                value: message,
            },
        ];
        return client.signAndBroadcast(signerAddress, data, fee, memo);
    };
}
