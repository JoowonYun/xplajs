"use strict";
/**
* This file and any referenced files were automatically generated by @cosmology/telescope@1.10.11
* DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
* and run the transpile command or npm scripts command that is used to regenerate this bundle.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRpcClient = exports.useRpcEndpoint = exports.DEFAULT_SIGNING_CLIENT_QUERY_KEY = exports.DEFAULT_RPC_ENDPOINT_QUERY_KEY = exports.DEFAULT_RPC_CLIENT_QUERY_KEY = void 0;
exports.isCacheResolver = isCacheResolver;
exports.buildUseQuery = buildUseQuery;
exports.buildUseMutation = buildUseMutation;
const extern_1 = require("./extern");
const helpers_1 = require("./helpers");
const helper_func_types_1 = require("./helper-func-types");
const react_query_1 = require("@tanstack/react-query");
exports.DEFAULT_RPC_CLIENT_QUERY_KEY = 'rpcClient';
exports.DEFAULT_RPC_ENDPOINT_QUERY_KEY = 'rpcEndPoint';
exports.DEFAULT_SIGNING_CLIENT_QUERY_KEY = 'signingClient';
function isCacheResolver(resolver) {
    return resolver !== null && resolver !== undefined && resolver.rpcEndpoint !== undefined && resolver.clientQueryKey !== undefined;
}
const useRpcEndpoint = ({ getter, options, rpcEndPointKey, }) => {
    const key = rpcEndPointKey || exports.DEFAULT_RPC_ENDPOINT_QUERY_KEY;
    return (0, react_query_1.useQuery)([key, getter], async () => {
        return await getter();
    }, options);
};
exports.useRpcEndpoint = useRpcEndpoint;
const useRpcClient = ({ options, clientResolver }) => {
    const queryClient = (0, react_query_1.useQueryClient)({
        context: options?.context
    });
    const key = clientResolver?.clientQueryKey || exports.DEFAULT_RPC_CLIENT_QUERY_KEY;
    return (0, react_query_1.useQuery)([key, clientResolver?.rpcEndpoint], async () => {
        if (!clientResolver?.rpcEndpoint) {
            throw new Error('rpcEndpoint is required');
        }
        const client = await (0, extern_1.getRpcClient)(clientResolver.rpcEndpoint);
        if (!client) {
            throw new Error('Failed to connect to rpc client');
        }
        queryClient.setQueryData([key], client);
        return client;
    }, options);
};
exports.useRpcClient = useRpcClient;
function buildUseQuery(opts) {
    return ({ request, options, clientResolver, customizedQueryKey, }) => {
        const queryClient = (0, react_query_1.useQueryClient)({
            context: options?.context
        });
        let rpcResolver;
        if ((0, helpers_1.isRpc)(clientResolver)) {
            rpcResolver = clientResolver;
        }
        else if (isCacheResolver(clientResolver)) {
            const key = clientResolver.clientQueryKey || exports.DEFAULT_RPC_CLIENT_QUERY_KEY;
            const queryKey = clientResolver.rpcEndpoint ? [key, clientResolver.rpcEndpoint] : [key];
            rpcResolver = queryClient.getQueryData(queryKey);
            if (!rpcResolver && clientResolver.rpcEndpoint) {
                rpcResolver = clientResolver.rpcEndpoint;
            }
        }
        else {
            rpcResolver = clientResolver;
        }
        const queryFn = opts.builderQueryFn(rpcResolver);
        return (0, react_query_1.useQuery)(customizedQueryKey || [opts.queryKeyPrefix, request], () => queryFn(request), options);
    };
}
function buildUseMutation(opts) {
    return ({ options, clientResolver }) => {
        const queryClient = (0, react_query_1.useQueryClient)({
            context: options?.context
        });
        let signingClientResolver;
        if ((0, helper_func_types_1.isISigningClient)(clientResolver)) {
            signingClientResolver = clientResolver;
        }
        else if (isCacheResolver(clientResolver)) {
            const key = clientResolver.clientQueryKey || exports.DEFAULT_SIGNING_CLIENT_QUERY_KEY;
            const queryKey = clientResolver.rpcEndpoint ? [key, clientResolver.rpcEndpoint] : [key];
            signingClientResolver = queryClient.getQueryData(queryKey);
        }
        else {
            clientResolver = clientResolver;
        }
        const mutationFn = opts.builderMutationFn(signingClientResolver);
        return (0, react_query_1.useMutation)((reqData) => mutationFn(reqData.signerAddress, reqData.message, reqData.fee, reqData.memo), options);
    };
}
